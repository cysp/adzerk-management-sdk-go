// Code generated by ogen, DO NOT EDIT.

package client

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *AdType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdType) encodeFields(e *jx.Encoder) {
	{
		if s.Height.Set {
			e.FieldStart("Height")
			s.Height.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("Id")
			s.ID.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Width.Set {
			e.FieldStart("Width")
			s.Width.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdType = [4]string{
	0: "Height",
	1: "Id",
	2: "Name",
	3: "Width",
}

// Decode decodes AdType from json.
func (s *AdType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdType to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Height":
			if err := func() error {
				s.Height.Reset()
				if err := s.Height.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Height\"")
			}
		case "Id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Width":
			if err := func() error {
				s.Width.Reset()
				if err := s.Width.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Width\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AdTypeList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AdTypeList) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("pageSize")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.TotalItems.Set {
			e.FieldStart("totalItems")
			s.TotalItems.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("totalPages")
			s.TotalPages.Encode(e)
		}
	}
}

var jsonFieldsNameOfAdTypeList = [5]string{
	0: "items",
	1: "page",
	2: "pageSize",
	3: "totalItems",
	4: "totalPages",
}

// Decode decodes AdTypeList from json.
func (s *AdTypeList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AdTypeList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]AdType, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AdType
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "pageSize":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageSize\"")
			}
		case "totalItems":
			if err := func() error {
				s.TotalItems.Reset()
				if err := s.TotalItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalItems\"")
			}
		case "totalPages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AdTypeList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AdTypeList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AdTypeList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Channel) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Channel) encodeFields(e *jx.Encoder) {
	{
		if s.AdTypes != nil {
			e.FieldStart("AdTypes")
			e.ArrStart()
			for _, elem := range s.AdTypes {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.CPM.Set {
			e.FieldStart("CPM")
			s.CPM.Encode(e)
		}
	}
	{
		if s.Commission.Set {
			e.FieldStart("Commission")
			s.Commission.Encode(e)
		}
	}
	{
		if s.CustomTargeting.Set {
			e.FieldStart("CustomTargeting")
			s.CustomTargeting.Encode(e)
		}
	}
	{
		if s.Engine.Set {
			e.FieldStart("Engine")
			s.Engine.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("Id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{
		if s.Keywords.Set {
			e.FieldStart("Keywords")
			s.Keywords.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("Title")
			s.Title.Encode(e)
		}
	}
}

var jsonFieldsNameOfChannel = [9]string{
	0: "AdTypes",
	1: "CPM",
	2: "Commission",
	3: "CustomTargeting",
	4: "Engine",
	5: "Id",
	6: "IsDeleted",
	7: "Keywords",
	8: "Title",
}

// Decode decodes Channel from json.
func (s *Channel) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Channel to nil")
	}
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "AdTypes":
			if err := func() error {
				s.AdTypes = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.AdTypes = append(s.AdTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AdTypes\"")
			}
		case "CPM":
			if err := func() error {
				s.CPM.Reset()
				if err := s.CPM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CPM\"")
			}
		case "Commission":
			if err := func() error {
				s.Commission.Reset()
				if err := s.Commission.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Commission\"")
			}
		case "CustomTargeting":
			if err := func() error {
				s.CustomTargeting.Reset()
				if err := s.CustomTargeting.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CustomTargeting\"")
			}
		case "Engine":
			if err := func() error {
				s.Engine.Reset()
				if err := s.Engine.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Engine\"")
			}
		case "Id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "Keywords":
			if err := func() error {
				s.Keywords.Reset()
				if err := s.Keywords.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Keywords\"")
			}
		case "Title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Channel")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Channel) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Channel) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChannelList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChannelList) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelIds != nil {
			e.FieldStart("ChannelIds")
			e.ArrStart()
			for _, elem := range s.ChannelIds {
				e.Int32(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfChannelList = [1]string{
	0: "ChannelIds",
}

// Decode decodes ChannelList from json.
func (s *ChannelList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChannelList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ChannelIds":
			if err := func() error {
				s.ChannelIds = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.ChannelIds = append(s.ChannelIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ChannelIds\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChannelList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChannelList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChannelList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChannelSiteMap) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChannelSiteMap) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelId.Set {
			e.FieldStart("ChannelId")
			s.ChannelId.Encode(e)
		}
	}
	{
		if s.FixedPaymentAmount.Set {
			e.FieldStart("FixedPaymentAmount")
			s.FixedPaymentAmount.Encode(e)
		}
	}
	{
		if s.Priority.Set {
			e.FieldStart("Priority")
			s.Priority.Encode(e)
		}
	}
	{
		if s.SiteId.Set {
			e.FieldStart("SiteId")
			s.SiteId.Encode(e)
		}
	}
}

var jsonFieldsNameOfChannelSiteMap = [4]string{
	0: "ChannelId",
	1: "FixedPaymentAmount",
	2: "Priority",
	3: "SiteId",
}

// Decode decodes ChannelSiteMap from json.
func (s *ChannelSiteMap) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChannelSiteMap to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ChannelId":
			if err := func() error {
				s.ChannelId.Reset()
				if err := s.ChannelId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ChannelId\"")
			}
		case "FixedPaymentAmount":
			if err := func() error {
				s.FixedPaymentAmount.Reset()
				if err := s.FixedPaymentAmount.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FixedPaymentAmount\"")
			}
		case "Priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Priority\"")
			}
		case "SiteId":
			if err := func() error {
				s.SiteId.Reset()
				if err := s.SiteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SiteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChannelSiteMap")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChannelSiteMap) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChannelSiteMap) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ChannelSiteMapList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ChannelSiteMapList) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("pageSize")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.TotalItems.Set {
			e.FieldStart("totalItems")
			s.TotalItems.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("totalPages")
			s.TotalPages.Encode(e)
		}
	}
}

var jsonFieldsNameOfChannelSiteMapList = [5]string{
	0: "items",
	1: "page",
	2: "pageSize",
	3: "totalItems",
	4: "totalPages",
}

// Decode decodes ChannelSiteMapList from json.
func (s *ChannelSiteMapList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ChannelSiteMapList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]ChannelSiteMap, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem ChannelSiteMap
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "pageSize":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageSize\"")
			}
		case "totalItems":
			if err := func() error {
				s.TotalItems.Reset()
				if err := s.TotalItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalItems\"")
			}
		case "totalPages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ChannelSiteMapList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ChannelSiteMapList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ChannelSiteMapList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateAdTypeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateAdTypeReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("Height")
		e.Int32(s.Height)
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{

		e.FieldStart("Width")
		e.Int32(s.Width)
	}
}

var jsonFieldsNameOfCreateAdTypeReq = [3]string{
	0: "Height",
	1: "Name",
	2: "Width",
}

// Decode decodes CreateAdTypeReq from json.
func (s *CreateAdTypeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateAdTypeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Height":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Height = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Height\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Width = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Width\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateAdTypeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateAdTypeReq) {
					name = jsonFieldsNameOfCreateAdTypeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateAdTypeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateAdTypeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChannelReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChannelReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("AdTypes")
		e.ArrStart()
		for _, elem := range s.AdTypes {
			e.Int32(elem)
		}
		e.ArrEnd()
	}
	{
		if s.CPM.Set {
			e.FieldStart("CPM")
			s.CPM.Encode(e)
		}
	}
	{

		e.FieldStart("Engine")
		e.Int32(s.Engine)
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{

		e.FieldStart("Title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfCreateChannelReq = [5]string{
	0: "AdTypes",
	1: "CPM",
	2: "Engine",
	3: "IsDeleted",
	4: "Title",
}

// Decode decodes CreateChannelReq from json.
func (s *CreateChannelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChannelReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "AdTypes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AdTypes = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.AdTypes = append(s.AdTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AdTypes\"")
			}
		case "CPM":
			if err := func() error {
				s.CPM.Reset()
				if err := s.CPM.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"CPM\"")
			}
		case "Engine":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Engine = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Engine\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "Title":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChannelReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00010101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChannelReq) {
					name = jsonFieldsNameOfCreateChannelReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChannelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChannelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateChannelSiteMapReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateChannelSiteMapReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("channelId")
		e.Int32(s.ChannelId)
	}
	{
		if s.Priority.Set {
			e.FieldStart("priority")
			s.Priority.Encode(e)
		}
	}
	{

		e.FieldStart("siteId")
		e.Int32(s.SiteId)
	}
}

var jsonFieldsNameOfCreateChannelSiteMapReq = [3]string{
	0: "channelId",
	1: "priority",
	2: "siteId",
}

// Decode decodes CreateChannelSiteMapReq from json.
func (s *CreateChannelSiteMapReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateChannelSiteMapReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channelId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ChannelId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channelId\"")
			}
		case "priority":
			if err := func() error {
				s.Priority.Reset()
				if err := s.Priority.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "siteId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.SiteId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"siteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateChannelSiteMapReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateChannelSiteMapReq) {
					name = jsonFieldsNameOfCreateChannelSiteMapReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateChannelSiteMapReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateChannelSiteMapReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateForChannelAdTypeReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateForChannelAdTypeReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("Height")
		e.Int32(s.Height)
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{

		e.FieldStart("Width")
		e.Int32(s.Width)
	}
}

var jsonFieldsNameOfCreateForChannelAdTypeReq = [3]string{
	0: "Height",
	1: "Name",
	2: "Width",
}

// Decode decodes CreateForChannelAdTypeReq from json.
func (s *CreateForChannelAdTypeReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateForChannelAdTypeReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Height":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.Height = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Height\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "Width":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.Width = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Width\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateForChannelAdTypeReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateForChannelAdTypeReq) {
					name = jsonFieldsNameOfCreateForChannelAdTypeReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateForChannelAdTypeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateForChannelAdTypeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateSiteReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateSiteReq) encodeFields(e *jx.Encoder) {
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{
		if s.NetworkMargin.Set {
			e.FieldStart("NetworkMargin")
			s.NetworkMargin.Encode(e)
		}
	}
	{

		e.FieldStart("Title")
		e.Str(s.Title)
	}
	{

		e.FieldStart("URL")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfCreateSiteReq = [4]string{
	0: "IsDeleted",
	1: "NetworkMargin",
	2: "Title",
	3: "URL",
}

// Decode decodes CreateSiteReq from json.
func (s *CreateSiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateSiteReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "NetworkMargin":
			if err := func() error {
				s.NetworkMargin.Reset()
				if err := s.NetworkMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMargin\"")
			}
		case "Title":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Title\"")
			}
		case "URL":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"URL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateSiteReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001100,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateSiteReq) {
					name = jsonFieldsNameOfCreateSiteReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateSiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateSiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateZoneReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateZoneReq) encodeFields(e *jx.Encoder) {
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{

		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		if s.SiteId.Set {
			e.FieldStart("SiteId")
			s.SiteId.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateZoneReq = [3]string{
	0: "IsDeleted",
	1: "Name",
	2: "SiteId",
}

// Decode decodes CreateZoneReq from json.
func (s *CreateZoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateZoneReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "Name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "SiteId":
			if err := func() error {
				s.SiteId.Reset()
				if err := s.SiteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SiteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateZoneReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateZoneReq) {
					name = jsonFieldsNameOfCreateZoneReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateZoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateZoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateAdTypeReq as json.
func (o OptCreateAdTypeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateAdTypeReq from json.
func (o *OptCreateAdTypeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateAdTypeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateAdTypeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateAdTypeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChannelReq as json.
func (o OptCreateChannelReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChannelReq from json.
func (o *OptCreateChannelReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateChannelReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateChannelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateChannelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateChannelSiteMapReq as json.
func (o OptCreateChannelSiteMapReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateChannelSiteMapReq from json.
func (o *OptCreateChannelSiteMapReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateChannelSiteMapReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateChannelSiteMapReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateChannelSiteMapReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateForChannelAdTypeReq as json.
func (o OptCreateForChannelAdTypeReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateForChannelAdTypeReq from json.
func (o *OptCreateForChannelAdTypeReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateForChannelAdTypeReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateForChannelAdTypeReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateForChannelAdTypeReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateSiteReq as json.
func (o OptCreateSiteReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateSiteReq from json.
func (o *OptCreateSiteReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateSiteReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateSiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateSiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateZoneReq as json.
func (o OptCreateZoneReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes CreateZoneReq from json.
func (o *OptCreateZoneReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptCreateZoneReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptCreateZoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptCreateZoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptFloat32 to nil")
	}
	o.Set = true
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt32 to nil")
	}
	o.Set = true
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int64 as json.
func (o OptInt64) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int64(int64(o.Value))
}

// Decode decodes int64 from json.
func (o *OptInt64) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt64 to nil")
	}
	o.Set = true
	v, err := d.Int64()
	if err != nil {
		return err
	}
	o.Value = int64(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt64) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt64) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptNilBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptNilBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilBool to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v bool
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes float32 as json.
func (o OptNilFloat32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Float32(float32(o.Value))
}

// Decode decodes float32 from json.
func (o *OptNilFloat32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilFloat32 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v float32
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Float32()
	if err != nil {
		return err
	}
	o.Value = float32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilFloat32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilFloat32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int32 as json.
func (o OptNilInt32) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Int32(int32(o.Value))
}

// Decode decodes int32 from json.
func (o *OptNilInt32) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilInt32 to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v int32
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Int32()
	if err != nil {
		return err
	}
	o.Value = int32(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilInt32) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilInt32) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateChannelReq as json.
func (o OptUpdateChannelReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateChannelReq from json.
func (o *OptUpdateChannelReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateChannelReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateChannelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateChannelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateChannelSiteMapReq as json.
func (o OptUpdateChannelSiteMapReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateChannelSiteMapReq from json.
func (o *OptUpdateChannelSiteMapReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateChannelSiteMapReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateChannelSiteMapReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateChannelSiteMapReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateSiteReq as json.
func (o OptUpdateSiteReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateSiteReq from json.
func (o *OptUpdateSiteReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateSiteReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateSiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateSiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateZoneReq as json.
func (o OptUpdateZoneReq) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes UpdateZoneReq from json.
func (o *OptUpdateZoneReq) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUpdateZoneReq to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUpdateZoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUpdateZoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Priority) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Priority) encodeFields(e *jx.Encoder) {
	{
		if s.ChannelId.Set {
			e.FieldStart("ChannelId")
			s.ChannelId.Encode(e)
		}
	}
	{
		if s.FloorPrice.Set {
			e.FieldStart("FloorPrice")
			s.FloorPrice.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("Id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsAdChain.Set {
			e.FieldStart("IsAdChain")
			s.IsAdChain.Encode(e)
		}
	}
	{
		if s.IsAdChainOptimized.Set {
			e.FieldStart("IsAdChainOptimized")
			s.IsAdChainOptimized.Encode(e)
		}
	}
	{
		if s.IsAdChainOrdered.Set {
			e.FieldStart("IsAdChainOrdered")
			s.IsAdChainOrdered.Encode(e)
		}
	}
	{
		if s.IsAuction.Set {
			e.FieldStart("IsAuction")
			s.IsAuction.Encode(e)
		}
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{
		if s.IsKeywordOptimized.Set {
			e.FieldStart("IsKeywordOptimized")
			s.IsKeywordOptimized.Encode(e)
		}
	}
	{
		if s.IsSecondPricing.Set {
			e.FieldStart("IsSecondPricing")
			s.IsSecondPricing.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.PassbackTimeout.Set {
			e.FieldStart("PassbackTimeout")
			s.PassbackTimeout.Encode(e)
		}
	}
	{
		if s.RelevancyScoreConfig.Set {
			e.FieldStart("RelevancyScoreConfig")
			s.RelevancyScoreConfig.Encode(e)
		}
	}
	{
		if s.RelevancyScoreConfigJSON.Set {
			e.FieldStart("RelevancyScoreConfigJSON")
			s.RelevancyScoreConfigJSON.Encode(e)
		}
	}
	{
		if s.SelectionAlgorithm.Set {
			e.FieldStart("SelectionAlgorithm")
			s.SelectionAlgorithm.Encode(e)
		}
	}
	{
		if s.SerializeRelevancyScoreConfigJSON.Set {
			e.FieldStart("SerializeRelevancyScoreConfigJSON")
			s.SerializeRelevancyScoreConfigJSON.Encode(e)
		}
	}
	{
		if s.Weight.Set {
			e.FieldStart("Weight")
			s.Weight.Encode(e)
		}
	}
}

var jsonFieldsNameOfPriority = [17]string{
	0:  "ChannelId",
	1:  "FloorPrice",
	2:  "Id",
	3:  "IsAdChain",
	4:  "IsAdChainOptimized",
	5:  "IsAdChainOrdered",
	6:  "IsAuction",
	7:  "IsDeleted",
	8:  "IsKeywordOptimized",
	9:  "IsSecondPricing",
	10: "Name",
	11: "PassbackTimeout",
	12: "RelevancyScoreConfig",
	13: "RelevancyScoreConfigJSON",
	14: "SelectionAlgorithm",
	15: "SerializeRelevancyScoreConfigJSON",
	16: "Weight",
}

// Decode decodes Priority from json.
func (s *Priority) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Priority to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "ChannelId":
			if err := func() error {
				s.ChannelId.Reset()
				if err := s.ChannelId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ChannelId\"")
			}
		case "FloorPrice":
			if err := func() error {
				s.FloorPrice.Reset()
				if err := s.FloorPrice.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"FloorPrice\"")
			}
		case "Id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "IsAdChain":
			if err := func() error {
				s.IsAdChain.Reset()
				if err := s.IsAdChain.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsAdChain\"")
			}
		case "IsAdChainOptimized":
			if err := func() error {
				s.IsAdChainOptimized.Reset()
				if err := s.IsAdChainOptimized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsAdChainOptimized\"")
			}
		case "IsAdChainOrdered":
			if err := func() error {
				s.IsAdChainOrdered.Reset()
				if err := s.IsAdChainOrdered.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsAdChainOrdered\"")
			}
		case "IsAuction":
			if err := func() error {
				s.IsAuction.Reset()
				if err := s.IsAuction.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsAuction\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "IsKeywordOptimized":
			if err := func() error {
				s.IsKeywordOptimized.Reset()
				if err := s.IsKeywordOptimized.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsKeywordOptimized\"")
			}
		case "IsSecondPricing":
			if err := func() error {
				s.IsSecondPricing.Reset()
				if err := s.IsSecondPricing.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsSecondPricing\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "PassbackTimeout":
			if err := func() error {
				s.PassbackTimeout.Reset()
				if err := s.PassbackTimeout.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PassbackTimeout\"")
			}
		case "RelevancyScoreConfig":
			if err := func() error {
				s.RelevancyScoreConfig.Reset()
				if err := s.RelevancyScoreConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RelevancyScoreConfig\"")
			}
		case "RelevancyScoreConfigJSON":
			if err := func() error {
				s.RelevancyScoreConfigJSON.Reset()
				if err := s.RelevancyScoreConfigJSON.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"RelevancyScoreConfigJSON\"")
			}
		case "SelectionAlgorithm":
			if err := func() error {
				s.SelectionAlgorithm.Reset()
				if err := s.SelectionAlgorithm.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SelectionAlgorithm\"")
			}
		case "SerializeRelevancyScoreConfigJSON":
			if err := func() error {
				s.SerializeRelevancyScoreConfigJSON.Reset()
				if err := s.SerializeRelevancyScoreConfigJSON.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SerializeRelevancyScoreConfigJSON\"")
			}
		case "Weight":
			if err := func() error {
				s.Weight.Reset()
				if err := s.Weight.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Weight\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Priority")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Priority) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Priority) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Site) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Site) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("Id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{
		if s.NetworkMargin.Set {
			e.FieldStart("NetworkMargin")
			s.NetworkMargin.Encode(e)
		}
	}
	{
		if s.PublisherAccountId.Set {
			e.FieldStart("PublisherAccountId")
			s.PublisherAccountId.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("Title")
			s.Title.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("Url")
			s.URL.Encode(e)
		}
	}
}

var jsonFieldsNameOfSite = [6]string{
	0: "Id",
	1: "IsDeleted",
	2: "NetworkMargin",
	3: "PublisherAccountId",
	4: "Title",
	5: "Url",
}

// Decode decodes Site from json.
func (s *Site) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Site to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "NetworkMargin":
			if err := func() error {
				s.NetworkMargin.Reset()
				if err := s.NetworkMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMargin\"")
			}
		case "PublisherAccountId":
			if err := func() error {
				s.PublisherAccountId.Reset()
				if err := s.PublisherAccountId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"PublisherAccountId\"")
			}
		case "Title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Title\"")
			}
		case "Url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Url\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Site")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Site) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Site) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SiteList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SiteList) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("pageSize")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.TotalItems.Set {
			e.FieldStart("totalItems")
			s.TotalItems.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("totalPages")
			s.TotalPages.Encode(e)
		}
	}
}

var jsonFieldsNameOfSiteList = [5]string{
	0: "items",
	1: "page",
	2: "pageSize",
	3: "totalItems",
	4: "totalPages",
}

// Decode decodes SiteList from json.
func (s *SiteList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SiteList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]Site, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Site
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "pageSize":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageSize\"")
			}
		case "totalItems":
			if err := func() error {
				s.TotalItems.Reset()
				if err := s.TotalItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalItems\"")
			}
		case "totalPages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SiteList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SiteList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SiteList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateChannelReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateChannelReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("AdTypes")
		e.ArrStart()
		for _, elem := range s.AdTypes {
			e.Int32(elem)
		}
		e.ArrEnd()
	}
	{

		e.FieldStart("Engine")
		e.Int32(s.Engine)
	}
	{

		e.FieldStart("Id")
		e.Int32(s.ID)
	}
	{

		e.FieldStart("Title")
		e.Str(s.Title)
	}
}

var jsonFieldsNameOfUpdateChannelReq = [4]string{
	0: "AdTypes",
	1: "Engine",
	2: "Id",
	3: "Title",
}

// Decode decodes UpdateChannelReq from json.
func (s *UpdateChannelReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateChannelReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "AdTypes":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.AdTypes = make([]int32, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem int32
					v, err := d.Int32()
					elem = int32(v)
					if err != nil {
						return err
					}
					s.AdTypes = append(s.AdTypes, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"AdTypes\"")
			}
		case "Engine":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Engine = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Engine\"")
			}
		case "Id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "Title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Title\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateChannelReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateChannelReq) {
					name = jsonFieldsNameOfUpdateChannelReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateChannelReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateChannelReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateChannelSiteMapReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateChannelSiteMapReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("channelId")
		e.Int32(s.ChannelId)
	}
	{

		e.FieldStart("priority")
		e.Int32(s.Priority)
	}
	{

		e.FieldStart("siteId")
		e.Int32(s.SiteId)
	}
}

var jsonFieldsNameOfUpdateChannelSiteMapReq = [3]string{
	0: "channelId",
	1: "priority",
	2: "siteId",
}

// Decode decodes UpdateChannelSiteMapReq from json.
func (s *UpdateChannelSiteMapReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateChannelSiteMapReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "channelId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ChannelId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"channelId\"")
			}
		case "priority":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Int32()
				s.Priority = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"priority\"")
			}
		case "siteId":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int32()
				s.SiteId = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"siteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateChannelSiteMapReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateChannelSiteMapReq) {
					name = jsonFieldsNameOfUpdateChannelSiteMapReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateChannelSiteMapReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateChannelSiteMapReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateSiteReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateSiteReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("Id")
		e.Int32(s.ID)
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{
		if s.NetworkMargin.Set {
			e.FieldStart("NetworkMargin")
			s.NetworkMargin.Encode(e)
		}
	}
	{

		e.FieldStart("Title")
		e.Str(s.Title)
	}
	{

		e.FieldStart("URL")
		json.EncodeURI(e, s.URL)
	}
}

var jsonFieldsNameOfUpdateSiteReq = [5]string{
	0: "Id",
	1: "IsDeleted",
	2: "NetworkMargin",
	3: "Title",
	4: "URL",
}

// Decode decodes UpdateSiteReq from json.
func (s *UpdateSiteReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateSiteReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "NetworkMargin":
			if err := func() error {
				s.NetworkMargin.Reset()
				if err := s.NetworkMargin.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"NetworkMargin\"")
			}
		case "Title":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Title\"")
			}
		case "URL":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := json.DecodeURI(d)
				s.URL = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"URL\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateSiteReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateSiteReq) {
					name = jsonFieldsNameOfUpdateSiteReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateSiteReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateSiteReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateZoneReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateZoneReq) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("Id")
		e.Int32(s.ID)
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{

		e.FieldStart("Name")
		e.Str(s.Name)
	}
	{
		if s.SiteId.Set {
			e.FieldStart("SiteId")
			s.SiteId.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateZoneReq = [4]string{
	0: "Id",
	1: "IsDeleted",
	2: "Name",
	3: "SiteId",
}

// Decode decodes UpdateZoneReq from json.
func (s *UpdateZoneReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateZoneReq to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Int32()
				s.ID = int32(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "Name":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "SiteId":
			if err := func() error {
				s.SiteId.Reset()
				if err := s.SiteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SiteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateZoneReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateZoneReq) {
					name = jsonFieldsNameOfUpdateZoneReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateZoneReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateZoneReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Zone) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Zone) encodeFields(e *jx.Encoder) {
	{
		if s.ID.Set {
			e.FieldStart("Id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsDeleted.Set {
			e.FieldStart("IsDeleted")
			s.IsDeleted.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("Name")
			s.Name.Encode(e)
		}
	}
	{
		if s.SiteId.Set {
			e.FieldStart("SiteId")
			s.SiteId.Encode(e)
		}
	}
}

var jsonFieldsNameOfZone = [4]string{
	0: "Id",
	1: "IsDeleted",
	2: "Name",
	3: "SiteId",
}

// Decode decodes Zone from json.
func (s *Zone) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Zone to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "Id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Id\"")
			}
		case "IsDeleted":
			if err := func() error {
				s.IsDeleted.Reset()
				if err := s.IsDeleted.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"IsDeleted\"")
			}
		case "Name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"Name\"")
			}
		case "SiteId":
			if err := func() error {
				s.SiteId.Reset()
				if err := s.SiteId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"SiteId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Zone")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Zone) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Zone) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ZoneList) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ZoneList) encodeFields(e *jx.Encoder) {
	{
		if s.Items != nil {
			e.FieldStart("items")
			e.ArrStart()
			for _, elem := range s.Items {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Page.Set {
			e.FieldStart("page")
			s.Page.Encode(e)
		}
	}
	{
		if s.PageSize.Set {
			e.FieldStart("pageSize")
			s.PageSize.Encode(e)
		}
	}
	{
		if s.TotalItems.Set {
			e.FieldStart("totalItems")
			s.TotalItems.Encode(e)
		}
	}
	{
		if s.TotalPages.Set {
			e.FieldStart("totalPages")
			s.TotalPages.Encode(e)
		}
	}
}

var jsonFieldsNameOfZoneList = [5]string{
	0: "items",
	1: "page",
	2: "pageSize",
	3: "totalItems",
	4: "totalPages",
}

// Decode decodes ZoneList from json.
func (s *ZoneList) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ZoneList to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			if err := func() error {
				s.Items = make([]Zone, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Zone
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "page":
			if err := func() error {
				s.Page.Reset()
				if err := s.Page.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"page\"")
			}
		case "pageSize":
			if err := func() error {
				s.PageSize.Reset()
				if err := s.PageSize.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pageSize\"")
			}
		case "totalItems":
			if err := func() error {
				s.TotalItems.Reset()
				if err := s.TotalItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalItems\"")
			}
		case "totalPages":
			if err := func() error {
				s.TotalPages.Reset()
				if err := s.TotalPages.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalPages\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ZoneList")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ZoneList) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ZoneList) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
